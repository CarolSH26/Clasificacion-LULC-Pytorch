# -*- coding: utf-8 -*-
"""Cuaderno_1_Parte2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-7WdvmHHk3IQvz6yCLXe2PHaNCgPmZj3
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# # Se utiliza la magia %%capture para suprimir la salida de los comandos de instalación
# 
# # Instalar o actualizar la librería folium para visualización de datos geoespaciales
# !pip -q install --upgrade folium
# 
# # Instalar la librería libspatialindex-dev necesaria para la indexación espacial
# !apt install libspatialindex-dev
# 
# # Instalar la librería rtree, que es útil para crear y manipular índices espaciales
# !pip -q install rtree
# 
# # Instalar geopandas, una librería que facilita el análisis de datos geoespaciales
# !pip -q install geopandas
# 
# # Instalar geojson, que se utiliza para manejar archivos en formato geojson
# !pip -q install geojson
# 
# # Instalar una versión específica de geemap para visualización interactiva de mapas
# !pip -q install geemap==0.17.3
# 
# # Desinstalar tornado y luego instalar una versión compatible de tornado (versión 5.1.0)
# !pip -q uninstall tornado -y
# !yes | pip install tornado==5.1.0
# 
# # Instalar rasterio, una librería para leer y escribir archivos raster (imágenes geoespaciales)
# !pip -q install rasterio
# 
# # Instalar tqdm para mostrar barras de progreso durante la ejecución de procesos largos
# !pip -q install tqdm
# 
# # Instalar eeconvert, que es útil para convertir datos entre diferentes formatos geoespaciales
# !pip -q install eeconvert
#

# Importaciones estándar
import os  # Proporciona funciones para interactuar con el sistema operativo, como trabajar con rutas y archivos.
from tqdm.notebook import tqdm  # Barra de progreso visual para loops en Jupyter notebooks.
import requests  # Para hacer peticiones HTTP.
import json  # Para trabajar con datos en formato JSON.

import pandas as pd  # Librería para análisis y manipulación de datos estructurados (tablas).
import numpy as np  # Librería para manejo de arrays y operaciones numéricas.
from PIL import Image  # Para abrir, manipular y guardar imágenes.

# Paquetes para procesamiento geoespacial
import geopandas as gpd  # Extensión de pandas para manejar datos geoespaciales.
import geojson  # Para leer y escribir archivos en formato GeoJSON.

import shapely  # Para operaciones geométricas como la creación y manipulación de geometrías.
import rasterio as rio  # Para leer y escribir archivos raster (imágenes geoespaciales).
from rasterio.plot import show  # Para mostrar imágenes raster.
import rasterio.mask  # Para realizar operaciones de máscara en datos raster.
from shapely.geometry import box  # Para crear cajas geométricas, típicamente usadas en análisis espacial.

# Librerías para mapeo y visualización
import matplotlib.pyplot as plt  # Para crear gráficos y visualizaciones.
import matplotlib.colors as cl  # Para trabajar con mapas de colores en visualizaciones.
import ee  # Para trabajar con Google Earth Engine.
import eeconvert as eec  # Para convertir datos entre diferentes formatos geoespaciales.
import geemap  # Para crear mapas interactivos usando herramientas geoespaciales.
import geemap.eefolium as emap  # Extensión para usar Earth Engine con folium.
import folium  # Librería para crear mapas interactivos.

# Librerías de aprendizaje profundo
import torch  # Para usar PyTorch, una librería de aprendizaje automático y profundo.
from torchvision import datasets, models, transforms  # Para trabajar con modelos preentrenados y transformaciones de imágenes.

# Montar Google Drive en el entorno de Google Colab
from google.colab import drive  # Importa la librería que permite interactuar con Google Drive.
drive.mount('/content/drive', force_remount=True)
# Monta Google Drive en el entorno de Colab en la ruta '/content/drive'.
# Si ya está montado, el parámetro 'force_remount=True' fuerza el remonte del mismo.

# Autenticación y inicialización de Google Earth Engine (GEE)
import ee  # Importa la librería de Google Earth Engine

# Autenticación para acceder a la API de GEE
ee.Authenticate()
# Esta función autentica tu cuenta de Google para poder acceder a los recursos de Google Earth Engine.
# Si es la primera vez que usas GEE, te pedirá que inicies sesión y autorices el acceso.

# Inicialización de Google Earth Engine
ee.Initialize(project="")
# Inicializa la API de Google Earth Engine, configurando el proyecto de GEE para usar sus servicios.
# En el parámetro `project`, puedes especificar un ID de proyecto en GCP (Google Cloud Platform), si es necesario.
# Si no especificas nada, usará el proyecto predeterminado asociado a tu cuenta de Google.

# Definición del código ISO de Alemania y nivel administrativo
ISO = 'DEU'  # "DEU" es el código ISO para Alemania
ADM = 'ADM3'  # Equivalente a los distritos administrativos

# Consultar la API de geoBoundaries para obtener los límites geoespaciales
url = f"https://www.geoboundaries.org/api/current/gbOpen/{ISO}/{ADM}"
# Se construye la URL para consultar la API de geoBoundaries, especificando el código ISO de Alemania (DEU)
# y el nivel administrativo (ADM3) para obtener los distritos administrativos.

# Realizar la solicitud GET para obtener los datos
r = requests.get(url)
# Realiza la solicitud HTTP GET a la URL construida para obtener los datos de los límites geográficos.

# Obtener la URL de descarga del archivo GeoJSON
download_path = r.json()["gjDownloadURL"]
# Extrae la URL de descarga del archivo GeoJSON de la respuesta JSON de la API.

# Descargar el archivo GeoJSON
filename = 'geoboundary.geojson'  # Especifica el nombre del archivo para guardar los datos.
geoboundary = requests.get(download_path).json()  # Descarga el archivo GeoJSON y lo convierte en un diccionario de Python.

# Guardar el resultado como un archivo GeoJSON
with open(filename, 'w') as file:
   geojson.dump(geoboundary, file)  # Guarda el objeto JSON descargado en un archivo local con formato GeoJSON.

# Leer los datos utilizando GeoPandas
geoboundary = gpd.read_file(filename)  # Usa GeoPandas para leer el archivo GeoJSON y cargarlo como un DataFrame geoespacial.
print("Dimensiones de los datos: {}".format(geoboundary.shape))
# Imprime las dimensiones del DataFrame (número de filas y columnas).

# Muestra una muestra aleatoria de 3 filas del DataFrame
geoboundary.sample(3)

# Definir el nombre de la forma que queremos visualizar
shape_name = 'Borken'  # 'Borken' es el nombre de la forma geoespacial que queremos filtrar y visualizar.

# Crear una figura y un eje para la visualización
fig, ax = plt.subplots(1, figsize=(10, 10))  # Crea una figura de tamaño 10x10 para mostrar el gráfico.

# Filtrar los datos por el nombre de la forma y graficarlos
geoboundary[geoboundary.shapeName == shape_name].plot('shapeName', legend=True, ax=ax)
# Filtra los datos geoespaciales en 'geoboundary' donde el nombre de la forma es igual a 'Borken'.
# Luego, grafica el resultado, usando 'shapeName' como la columna que determina el color de los polígonos.
# Se agrega una leyenda y se dibuja sobre el eje 'ax'.

def generar_imagen(
    region,
    producto='COPERNICUS/S2',
    fecha_minima='2018-01-01',
    fecha_maxima='2020-01-01',
    rango_min=0,
    rango_max=2000,
    porcentaje_nubes=10
):
    """
    Genera una imagen de Sentinel-2 filtrada por nubes y agregada por mediana
    desde Google Earth Engine usando la API de Python de Earth Engine.

    Parámetros:
      region (ee.Geometry): La geometría del área de interés a la cual filtrar.
      producto (str): ID del asset de Earth Engine
        Puedes encontrar la lista completa de IDs de ImageCollection
        en https://developers.google.com/earth-engine/datasets
      fecha_minima (str): Fecha mínima para adquirir la colección de imágenes satelitales
      fecha_maxima (str): Fecha máxima para adquirir la colección de imágenes satelitales
      rango_min (int): Valor mínimo para el rango de visualización
      rango_max (int): Valor máximo para el rango de visualización
      porcentaje_nubes (float): El porcentaje de nubes para filtrar (por defecto 10)

    Retorna:
      ee.image.Image: Imagen generada de Sentinel-2 recortada a la región de interés
    """

    # Generar composición agregada por mediana
    imagen = ee.ImageCollection(producto)\
        .filterBounds(region)\
        .filterDate(str(fecha_minima), str(fecha_maxima))\
        .filter(ee.Filter.lt("CLOUDY_PIXEL_PERCENTAGE", porcentaje_nubes))\
        .median()

    # Obtener las bandas RGB
    imagen = imagen.visualize(bands=['B4', 'B3', 'B2'], min=rango_min, max=rango_max)
    # Nota que el valor máximo de las bandas RGB se establece en 65535
    # porque las bandas de Sentinel-2 son enteros de 16 bits
    # con un rango numérico completo de [0, 65535] (el máximo es 2^16 - 1);
    # sin embargo, los valores reales son mucho más pequeños que el valor máximo.
    # Fuente: https://stackoverflow.com/a/63912278/4777141

    return imagen.clip(region)  # Retorna la imagen recortada a la región de interés.

# Obtener la geometría de la forma para Kreis Borken
region = geoboundary.loc[geoboundary.shapeName == shape_name]
# Filtra el DataFrame para obtener la región donde el nombre de la forma (shapeName) es igual a "Borken".

# Obtener el centroide de la región
centroid = region.iloc[0].geometry.centroid.coords[0]
# Obtiene el centroide de la primera geometría en el DataFrame filtrado y extrae las coordenadas del centroide.

# Convertir el GeoDataFrame a una colección de características (FeatureCollection) para usar en GEE
region = eec.gdfToFc(region)  # Convierte el GeoDataFrame a una colección de características (FeatureCollection) de Earth Engine.

# Generar la imagen RGB utilizando GEE
imagen = generate_image(
    region,  # La región de interés (en formato FeatureCollection).
    producto='COPERNICUS/S2',  # Producto de imágenes de Sentinel-2A.
    fecha_minima='2021-01-01',  # Fecha mínima para obtener imágenes dentro del año 2021.
    fecha_maxima='2021-12-31',  # Fecha máxima para obtener imágenes dentro del año 2021.
    porcentaje_nubes=10,  # Filtrar imágenes con cobertura de nubes >= 10.0%.
)

# Visualizar el mapa
Mapa = emap.Map(center=[centroid[1], centroid[0]], zoom=10)
# Crea un mapa centrado en las coordenadas del centroide de la región de interés con un nivel de zoom de 10.
Mapa.addLayer(imagen, {}, 'Sentinel2')  # Agrega la capa de la imagen generada con GEE al mapa.
Mapa.addLayerControl()  # Agrega los controles para cambiar la visualización de las capas en el mapa.
Mapa  # Muestra el mapa interactivo.

def exportar_imagen(imagen, nombre_archivo, region, carpeta):
    """Exportar imagen a Google Drive.

    Parámetros:
      imagen (ee.image.Image): Imagen generada de Sentinel-2.
      nombre_archivo (str): Nombre del archivo de la imagen, sin la extensión del archivo.
      region (ee.geometry.Geometry): La geometría del área de interés a la cual se filtrará.
      carpeta (str): La carpeta de destino en tu Google Drive.

    Retorna:
      ee.batch.Task: Una instancia de tarea
    """

    print('Exportando a {}.tif ...'.format(nombre_archivo))

    # Crear la tarea de exportación
    tarea = ee.batch.Export.image.toDrive(
      image=imagen,  # La imagen a exportar.
      driveFolder=carpeta,  # La carpeta de destino en Google Drive.
      scale=10,  # Escala de píxeles, en metros (resolución de la imagen).
      region=region.geometry(),  # La geometría que define el área de la imagen a exportar.
      description=nombre_archivo,  # Descripción de la tarea (se usará como nombre de archivo).
      fileFormat='GeoTIFF',  # Formato de archivo para la exportación.
      crs='EPSG:4326',  # Sistema de referencia de coordenadas (en este caso, WGS84).
      maxPixels=900000000  # Número máximo de píxeles a procesar.
    )
    tarea.start()  # Inicia la tarea de exportación.

    return tarea  # Retorna la instancia de la tarea de exportación.

# Especificar la carpeta de destino en Google Drive
carpeta = 'Colab Notebooks'  # Cambia esto a la carpeta de destino en tu Google Drive donde quieres guardar el archivo.

# Llamar a la función para exportar la imagen
tarea = exportar_imagen(imagen, shape_name, region, carpeta)
# Llama a la función `exportar_imagen`, pasando la imagen generada, el nombre del archivo (shape_name),
# la región de interés (region), y la carpeta de destino (carpeta) en Google Drive.

# Consultar el estado de la tarea de exportación
tarea.status()
# Esta función devuelve el estado de la tarea de exportación (por ejemplo, si está en proceso, completada o si hubo un error).

# Cambia esto por la ruta de tu archivo de imagen
cwd = './drive/My Drive/Colab Notebooks/'  # Ruta del directorio donde se guarda el archivo en Google Drive
tif_file = os.path.join(cwd, '{}.tif'.format(shape_name))  # Ruta completa al archivo TIFF usando el nombre de la forma.

# Descomentar esto para descargar el archivo TIF si no existe
if not os.path.isfile(tif_file):  # Verifica si el archivo TIF ya existe en la ruta especificada.
  tif_file = '{}.tif'.format(shape_name)  # Si no existe, ajusta el nombre del archivo con la forma.
  !gdown "12VJQBht4n544OXh4dmugqMESXXxRlBcU"  # Descarga el archivo TIF usando el enlace de Google Drive.

# Abrir el archivo de imagen utilizando Rasterio
imagen = rio.open(tif_file)  # Abre el archivo TIF usando la librería Rasterio.

# Filtrar los límites geoespaciales correspondientes a la forma seleccionada
limite = geoboundary[geoboundary.shapeName == shape_name]  # Filtra los límites geoespaciales para la forma de interés.

# Graficar la imagen y el límite correspondiente
fig, ax = plt.subplots(figsize=(15, 15))  # Crea una figura de tamaño 15x15 para la visualización.
limite.plot(facecolor="none", edgecolor='red', ax=ax)  # Dibuja el límite de la forma en color rojo.
show(imagen, ax=ax)  # Muestra la imagen utilizando Rasterio sobre el mismo eje.

def generar_mosaicos(image_file, output_file, area_str, size=64):
    """Genera mosaicos de polígonos de tamaño 64x64.

    Parámetros:
      image_file (str): Ruta del archivo de la imagen (.tif)
      output_file (str): Ruta del archivo de salida (.geojson)
      area_str (str): Nombre de la región
      size (int): Tamaño de la ventana (64x64 píxeles)

    Retorna:
      DataFrame de GeoPandas: Contiene mosaicos de polígonos de tamaño 64x64
    """

    # Abrir la imagen raster utilizando Rasterio
    raster = rio.open(image_file)
    width, height = raster.shape  # Obtener las dimensiones de la imagen (ancho y alto)

    # Crear un diccionario que almacenará nuestros mosaicos de polígonos de tamaño 64x64
    # Luego lo convertiremos en un DataFrame de GeoPandas.
    geo_dict = { 'id': [], 'geometry': [] }
    index = 0  # Variable para identificar cada mosaico

    # Hacer un desplazamiento sobre la imagen raster
    with tqdm(total=width * height) as pbar:
      for w in range(0, width, size):  # Iterar sobre el ancho con pasos de tamaño de ventana
          for h in range(0, height, size):  # Iterar sobre la altura con pasos de tamaño de ventana
              # Crear una ventana del tamaño deseado
              window = rio.windows.Window(h, w, size, size)
              # Obtener los límites georreferenciados de la ventana
              bbox = rio.windows.bounds(window, raster.transform)
              # Crear una geometría de tipo caja (bbox) usando Shapely
              bbox = box(*bbox)

              # Crear un ID único para cada geometría
              uid = '{}-{}'.format(area_str.lower().replace(' ', '_'), index)

              # Actualizar el diccionario
              geo_dict['id'].append(uid)
              geo_dict['geometry'].append(bbox)

              index += 1
              pbar.update(size * size)  # Actualizar la barra de progreso con el tamaño de la ventana

    # Convertir el diccionario a un DataFrame de GeoPandas
    resultados = gpd.GeoDataFrame(pd.DataFrame(geo_dict))
    # Establecer el Sistema de Referencia Espacial (CRS

# Especificar la ruta del archivo de salida
output_file = os.path.join(cwd, '{}.geojson'.format(shape_name))
# Generar la ruta completa del archivo GeoJSON de salida usando el nombre de la forma.

# Llamar a la función para generar los mosaicos de la imagen
mosaicos = generar_mosaicos(tif_file, output_file, shape_name, size=64)
# Llama a la función `generar_mosaicos`, pasando el archivo TIF, la ruta del archivo de salida,
# el nombre de la región (shape_name), y el tamaño del mosaico (64x64).

# Descomentar esto para descargar el archivo GeoJSON
#if not os.path.isfile(output_file):
#  output_file = '{}.geojson'.format(shape_name)  # Ajustar el nombre del archivo si no existe.
#  !gdown "1h7L17F0SD1xuppWddqAVh64zxH7Cjf9p"  # Descargar el archivo GeoJSON desde Google Drive si no existe.

# Imprimir las dimensiones de los datos generados
print('Dimensiones de los datos: {}'.format(mosaicos.shape))
# Imprime las dimensiones del DataFrame generado (número de filas y columnas).

# Mostrar las primeras 3 filas del DataFrame
mosaicos.head(3)
# Muestra las primeras 3 filas del DataFrame de mosaicos generados para su inspección.

# Abrir el archivo de imagen utilizando Rasterio
imagen = rio.open(tif_file)  # Abre el archivo TIFF utilizando Rasterio.

# Crear una figura y un eje para la visualización
fig, ax = plt.subplots(figsize=(15, 15))  # Crea una figura de tamaño 15x15 para la visualización.

# Dibujar los mosaicos sobre el mapa
tiles.plot(facecolor="none", edgecolor='red', ax=ax)
# Dibuja los mosaicos (polígonos) usando GeoPandas, con borde rojo y sin color de relleno (facecolor="none").

# Mostrar la imagen raster sobre los mosaicos
show(imagen, ax=ax)
# Muestra la imagen raster en el mismo gráfico, usando Rasterio, sobre los mosaicos.

# Abrir el archivo de imagen utilizando Rasterio
imagen = rio.open(tif_file)  # Abre el archivo TIFF utilizando Rasterio.

# Función sjoin de GeoPandas para realizar una unión espacial
mosaicos = gpd.sjoin(tiles, boundary, op='within')
# Realiza una unión espacial entre los mosaicos y la región de interés (boundary),
# seleccionando los mosaicos que están dentro de la región definida por 'boundary' (op='within').

# Crear una figura y un eje para la visualización
fig, ax = plt.subplots(figsize=(15, 15))  # Crea una figura de tamaño 15x15 para la visualización.

# Dibujar los mosaicos sobre el mapa
mosaicos.plot(facecolor="none", edgecolor='red', ax=ax)
# Dibuja los mosaicos seleccionados (que están dentro de la región) con borde rojo y sin color de relleno.

# Mostrar la imagen raster sobre los mosaicos
show(imagen, ax=ax)
# Muestra la imagen raster (por ejemplo, la imagen de Sentinel-2) sobre los mosaicos seleccionados en el mismo gráfico.

def mostrar_recorte(imagen, forma, titulo=''):
    """Recorta una imagen basada en la forma del polígono.
    Referencia: https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html#rasterio.mask.mask

    Parámetros:
      imagen (str): Ruta del archivo de la imagen (.tif)
      forma (geometry): El mosaico con el cual se recortará la imagen
      titulo (str): Título de la imagen
    """

    # Abrir la imagen raster utilizando Rasterio
    with rio.open(imagen) as src:
        # Recortar la imagen utilizando la máscara de la forma
        imagen_recortada, transformacion_recorte = rio.mask.mask(src, forma, crop=True)

        # Recortar el borde negro (cero)
        _, x_no_cero, y_no_cero = np.nonzero(imagen_recortada)  # Encontrar las coordenadas no cero
        imagen_recortada = imagen_recortada[
            :,
            np.min(x_no_cero):np.max(x_no_cero),  # Recortar el eje X
            np.min(y_no_cero):np.max(y_no_cero)   # Recortar el eje Y
        ]

        # Visualizar la imagen recortada
        show(imagen_recortada, title=titulo)

# Llamada a la función para recortar y mostrar la imagen
mostrar_recorte(tif_file, [tiles.iloc[5]['geometry']])

# Clases de Uso y Cobertura del Suelo (LULC)
clases = [
  'CultivoAnual',  # Cultivos anuales
  'Bosque',  # Bosque
  'VegetaciónHerbácea',  # Vegetación herbácea
  'Autopista',  # Carreteras principales
  'Industrial',  # Zonas industriales
  'Pastizal',  # Pastizales
  'CultivoPermanente',  # Cultivos permanentes
  'Residencial',  # Áreas residenciales
  'Río',  # Ríos
  'MarLago'  # Mar o lagos
]

# Configurar el dispositivo (GPU si está disponible, sino CPU)
dispositivo = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
# Verifica si hay una GPU disponible y la usa, si no, usa la CPU.

# Ruta al archivo del modelo
archivo_modelo = cwd + '/models/best_model.pth'  # Especifica la ruta al archivo donde se guardará el modelo.

# Descomentar esto para descargar el archivo del modelo si no está presente
if not os.path.isfile(archivo_modelo):  # Verifica si el archivo del modelo existe.
    archivo_modelo = 'best_model.pth'  # Ajusta el nombre del archivo si no se encuentra.
    !gdown "13AFOESwxKmexCoOeAbPSX_wr-hGOb9YY"  # Descarga el archivo del modelo desde Google Drive usando el enlace.

# Cargar el modelo preentrenado ResNet50
modelo = models.resnet50(pretrained=True)  # Carga el modelo ResNet50 preentrenado en ImageNet.
num_ftrs = modelo.fc.in_features  # Obtiene el número de características de entrada de la capa final (fc).
modelo.fc = torch.nn.Linear(num_ftrs, 10)  # Modifica la capa final para que tenga 10 salidas (por ejemplo, 10 clases).
modelo.load_state_dict(torch.load(archivo_modelo, map_location=dispositivo))  # Carga los pesos del modelo en el dispositivo especificado.
modelo.eval()  # Establece el modelo en modo evaluación.

# Confirmación de que el modelo se ha cargado exitosamente
print('El archivo del modelo {} se cargó exitosamente.'.format(archivo_modelo))

# Media y desviación estándar de ImageNet para normalización
imagenet_media, imagenet_desviacion = [0.485, 0.456, 0.406], [0.229, 0.224, 0.225]
# Estos son los valores estándar de la media y la desviación estándar para las imágenes preentrenadas en ImageNet.

# Definir las transformaciones a aplicar a la imagen
transformacion = transforms.Compose([
    transforms.Resize(224),  # Redimensiona la imagen a 224x224 píxeles.
    transforms.CenterCrop(224),  # Recorta el centro de la imagen a 224x224 píxeles.
    transforms.ToTensor(),  # Convierte la imagen a un tensor.
    transforms.Normalize(imagenet_media, imagenet_desviacion)  # Normaliza la imagen con la media y desviación estándar de ImageNet.
])

def predecir_recorte(imagen, forma, clases, modelo, mostrar=False):
    """Genera la predicción del modelo utilizando un modelo entrenado.

    Parámetros:
      imagen (str): Ruta del archivo de la imagen (.tiff)
      forma (geometry): El mosaico con el cual se recortará la imagen
      clases (list): Lista de clases de Uso y Cobertura del Suelo (LULC)
      modelo: El modelo entrenado para hacer predicciones
      mostrar (bool): Si se debe mostrar la imagen recortada (por defecto False)

    Retorna:
      str: Etiqueta predicha
    """

    with rio.open(imagen) as src:
        # Recortar la imagen original usando la forma del polígono
        # Más información aquí:
        # https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html#rasterio.mask.mask
        imagen_recortada, transformacion_recorte = rio.mask.mask(src, forma, crop=True)

        # Recortar el borde negro (cero)
        _, x_no_cero, y_no_cero = np.nonzero(imagen_recortada)
        imagen_recortada = imagen_recortada[
            :,
            np.min(x_no_cero):np.max(x_no_cero),
            np.min(y_no_cero):np.max(y_no_cero)
        ]

        # Obtener los metadatos de la imagen original y actualizarlos
        # con el ancho, alto y transformada de la imagen recortada
        meta_recorte = src.meta
        meta_recorte.update({
            "driver": "GTiff",  # Formato del archivo
            "height": imagen_recortada.shape[1],  # Alto de la imagen recortada
            "width": imagen_recortada.shape[2],  # Ancho de la imagen recortada
            "transform": transformacion_recorte  # Transformación geoespacial de la imagen recortada
        })

        # Guardar la imagen recortada como un archivo temporal TIFF.
        archivo_temporal_tif = 'temp.tif'
        with rio.open(archivo_temporal_tif, "w", **meta_recorte) as dest:
            dest.write(imagen_recortada)

        # Abrir la imagen recortada y generar la predicción
        # usando el modelo entrenado en Pytorch
        imagen = Image.open(archivo_temporal_tif)
        entrada = transform(imagen)  # Aplicar las transformaciones definidas previamente
        salida = modelo(entrada.unsqueeze(0))  # Realizar la predicción
        _, pred = torch.max(salida, 1)  # Obtener la clase predicha
        etiqueta = str(clases[int(pred[0])])  # Convertir la clase predicha a su etiqueta correspondiente

        if mostrar:
            imagen_recortada.show(title=etiqueta)  # Mostrar la imagen recortada con el título de la etiqueta predicha

        return etiqueta  # Retornar la etiqueta predicha

    return None  # Si algo sale mal, retornar None

# Comenzar la predicción del modelo
etiquetas = []  # Almacenar las predicciones

# Realizar la predicción para cada mosaico en el DataFrame de tiles
for indice in tqdm(range(len(tiles)), total=len(tiles)):
    # Llamar a la función `predict_crop` para cada mosaico
    etiqueta = predecir_recorte(tif_file, [tiles.iloc[indice]['geometry']], clases, modelo)
    etiquetas.append(etiqueta)  # Agregar la etiqueta predicha a la lista

# Añadir las predicciones como una nueva columna en el DataFrame de tiles
tiles['pred'] = etiquetas

# Guardar las predicciones en un archivo GeoJSON
ruta_archivo = os.path.join(cwd, "{}_preds.geojson".format(shape_name))
# Especifica la ruta donde se guardarán las predicciones en formato GeoJSON
tiles.to_file(ruta_archivo, driver="GeoJSON")  # Guardar el DataFrame como archivo GeoJSON

# Mostrar las primeras 3 filas del DataFrame de tiles con las predicciones
tiles.head(3)

# Definir la ruta del archivo donde se guardarán las predicciones
ruta_archivo = os.path.join(cwd, "{}_preds.geojson".format(shape_name))
# Genera la ruta del archivo para guardar las predicciones, usando el nombre de la forma.

# Descomentar esto para descargar las predicciones del modelo si no están presentes
if not os.path.isfile(ruta_archivo):
  # Verifica si el archivo de predicciones ya existe.
  ruta_archivo = "{}_preds.geojson".format(shape_name)  # Ajusta la ruta si no se encuentra el archivo.
  !gdown "1LN4efjd3WPGB1TtNiaHcRbFyBzbFY52A"  # Descarga el archivo de predicciones desde Google Drive usando el enlace.

# Leer el archivo de predicciones usando GeoPandas
tiles = gpd.read_file(ruta_archivo)
# Lee el archivo GeoJSON de las predicciones usando GeoPandas y lo carga en el DataFrame 'tiles'.

# Mostrar las primeras 3 filas del DataFrame de predicciones
tiles.head(3)
# Muestra las primeras 3 filas del DataFrame para inspeccionar las predicciones.

# Mapeamos cada clase a un color correspondiente
colores = {
  'CultivoAnual' : 'lightgreen',  # Color para la clase 'CultivoAnual'
  'Bosque' : 'forestgreen',  # Color para la clase 'Bosque'
  'VegetaciónHerbácea' : 'yellowgreen',  # Color para la clase 'VegetaciónHerbácea'
  'Autopista' : 'gray',  # Color para la clase 'Autopista'
  'Industrial' : 'red',  # Color para la clase 'Industrial'
  'Pastizal' : 'mediumseagreen',  # Color para la clase 'Pastizal'
  'CultivoPermanente' : 'chartreuse',  # Color para la clase 'CultivoPermanente'
  'Residencial' : 'magenta',  # Color para la clase 'Residencial'
  'Río' : 'dodgerblue',  # Color para la clase 'Río'
  'MarLago' : 'blue'  # Color para la clase 'MarLago'
}

# Asignar el color correspondiente a cada clase predicha
tiles['color'] = tiles["pred"].apply(
  lambda x: cl.to_hex(colores.get(x))  # Usamos la función 'to_hex' para convertir el color a formato hexadecimal.
)

# Mostrar las primeras 2 filas del DataFrame con los colores asignados
tiles.head(2)

# Crear el mapa centrado en el centroide
mapa = folium.Map(location=[centroid[1], centroid[0]], zoom_start=10)
# Instancia un mapa de **Folium** centrado en el centroide de la región de interés, con un nivel de zoom inicial de 10.

# Añadir el mapa base de Google Satellite
folium.TileLayer(
      tiles='https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',  # URL para las imágenes satelitales de Google
      attr='Google',  # Atributo que indica la fuente del mapa
      name='Google Satellite',  # Nombre de la capa
      overlay=True,  # Indica que es una capa superpuesta
      control=True  # Habilita el control de la capa en el mapa
).add_to(mapa)  # Añadir la capa al mapa

# Añadir el mapa de Uso y Cobertura del Suelo (LULC) con leyenda
leyenda_txt = '{txt}'  # Plantilla de texto para la leyenda
for etiqueta, color in colores.items():  # Iterar sobre las clases y colores
    # Crear el texto para la leyenda con el nombre de la clase y el color correspondiente
    nombre = leyenda_txt.format(txt=etiqueta, col=color)
    grupo_feature = folium.FeatureGroup(name=nombre)  # Crear un grupo de características para cada clase

    # Filtrar las subregiones que corresponden a la clase actual
    subtiles = tiles[tiles.pred == etiqueta]
    if len(subtiles) > 0:
        # Añadir el archivo GeoJSON al grupo de características
        folium.GeoJson(
            subtiles,  # Los datos GeoJSON para la clase actual
            style_function=lambda feature: {  # Estilo para las características
                'fillColor': feature['properties']['color'],  # Usar el color asignado
                'color': 'black',  # Color del borde
                'weight': 1,  # Grosor del borde
                'fillOpacity': 0.5,  # Opacidad del relleno
            },
            name='Mapa LULC'  # Nombre de la capa
        ).add_to(grupo_feature)
        mapa.add_child(grupo_feature)  # Añadir el grupo de características al mapa

# Añadir control de capas al mapa
folium.LayerControl().add_to(mapa)
# Añadir el control de capas al mapa para poder activar y desactivar las capas visibles

mapa  # Mostrar el mapa interactivo